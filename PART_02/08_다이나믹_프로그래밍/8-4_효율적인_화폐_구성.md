## 8-4. 효율적인 화폐 구성

### 문제
N가지 종류의 화폐가 있다. 이 화폐들의 개수를 최소한으로 이용해서 그 가치의 합이 M원이 되도록 하려고 한다. 이때 각 화폐는 몇 개라도 사용할 수 있으며, 사용한 화폐의 구성은 같지만 순서만 다른 것은 같은 경우로 구분한다. 예를 들어 2원, 3원 단위의 화폐가 있을 때는 15원을 만들기 위해 3원을 5개 사용하는 것이 가장 최소한의 화폐 개수이다.  

입력 조건  
\- 첫째 줄: N, M (N은 1 이상 100 이하, M은 1 이상 10000 이하)
\- 이후 N개의 줄에는 각 화폐의 가치가 주어진다. 화폐의 가치는 10000보다 작거나 같은 자연수이다.  

출력 조건  
\- 경우의 수 X를 출력한다. (불가능 할 때는 -1을 출력)  

### 답안 예시
```python
# 정수 N, M을 입력 받기
n, m = map(int, input().split())
# N개의 화폐 단위 정보를 입력 받기
array = []
for i in range(n):
    array.append(int(input()))

# 한 번 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [10001] * (m + 1)

# 다이나믹 프로그래밍(Dynamic Programming) 진행(보텀업)
d[0] = 0
for i in range(n):
    for j in range(array[i], m + 1):
        if d[j - array[i]] != 10001: # (i - k)원을 만드는 방법이 존재하는 경우
            d[j] = min(d[j], d[j - array[i]] + 1)

# 계산된 결과 출력
if d[m] == 10001: # 최종적으로 M원을 만드는 방법이 없는 경우
    print(-1)
else:
    print(d[m])
```
이 문제는 적은 금액부터 큰 금액까지 확인하며 차례대로 만들 수 있는 최소한의 화폐 개수를 찾으면 된다. 금액 x를 만들 수 있는 최소한의 화폐 개수를 aₓ, 화폐의 단위를 k라고 했을 때 아래와 같이 점화식을 작성할 수 있다. aₓ₋ₖ는 금액 (i - k)를 만들 수 있는 최소한의 화폐 개수를 의미한다.  

- aₓ₋ₖ를 만드는 방법이 존재하는 경우. aₓ = min(aₓ,aₓ₋ₖ+1)
- aₓ₋ₖ를 만드는 방법이 존재하지 않는 경우. aₓ = 10001

이 점화식을 모든 화폐 단위에 대하여 차례대로 적용하면 된다. 실제로 문제를 풀기 위해서는 가장 먼저 K의 크기만큼 리스트를 할당한다. 이후 각 인덱스를 ‘금액’으로 고려하여 메모이제이션을 진행한다.  

초기화 작업으로 각 인덱스에 해당하는 값으로 10001을 설정한다. 10001은 특정 금액을 만들 수 있는 화폐 구성이 가능하지 않다는 의미로, M의 최대 크기가 10000이므로 불가능한 수로 10001이라는 값을 설정했으나, 더 큰 수여도 상관없다. 또한 0원의 경우, 화폐를 하나도 사용하지 않았을 때 만들 수 있으므로 값으로 0을 설정한다.

이후 화폐 단위를 하나씩 점화식에 대입하여 리스트의 각 인덱스 값을 갱신해나간다. 모든 화폐 단위에 대한 인덱스 갱신이 끝난 후 나온 리스트의 m번째 값을 출력한다.
- - -
DP에 대해 제대로 감을 잡지 못하고 있는 것 같다. 우선 점화식을 세우는 것이 익숙치 않아 문제 해결을 위한 아이디어를 생각해내는 것부터가 어렵다. 메모이제이션 등을 사용해 코드를 작성하는 방법도 잘 떠올리지 못하는 중이다. DP의 개념을 다시 공부한 후, 다양한 문제를 풀어보며 숙달할 필요가 있겠다.
